
<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <title>–ö–∞—Ä—Ç–∞ —Å–æ–∫—Ä–æ–≤–∏—â</title>
  <style>
    body {
      font-family: monospace;
      background-color: #fdf6e3;
      margin: 0;
      padding: 2em;
    }
    #log {
      white-space: pre-wrap;
      border: 1px solid #ccc;
      background: #fff;
      height: 300px;
      overflow-y: auto;
      padding: 1em;
      margin-bottom: 1em;
    }
    button {
      margin: 0.2em;
      padding: 0.5em 1em;
    }
  </style>
</head>
<body>
  <h1>–ö–∞—Ä—Ç–∞ —Å–æ–∫—Ä–æ–≤–∏—â üó∫Ô∏è</h1>
  <div id="log"></div>
  <div>
    <button onclick="send('–≤–≤–µ—Ä—Ö')">–≤–≤–µ—Ä—Ö</button>
    <button onclick="send('–≤–Ω–∏–∑')">–≤–Ω–∏–∑</button>
    <button onclick="send('–≤–ª–µ–≤–æ')">–≤–ª–µ–≤–æ</button>
    <button onclick="send('–≤–ø—Ä–∞–≤–æ')">–≤–ø—Ä–∞–≤–æ</button>
    <button onclick="restart()">–∑–∞–Ω–æ–≤–æ</button>
  </div>

  <script>
    const log = document.getElementById('log');

    const directions = {
      "–≤–≤–µ—Ä—Ö": [-1, 0],
      "–≤–Ω–∏–∑": [1, 0],
      "–≤–ª–µ–≤–æ": [0, -1],
      "–≤–ø—Ä–∞–≤–æ": [0, 1]
    };

    function logMessage(msg) {
      log.textContent += msg + "\n";
      log.scrollTop = log.scrollHeight;
    }

    class Cell {
      constructor() {
        this.walls = { up: false, down: false, left: false, right: false };
        this.object = null;
      }
    }

    class Player {
      constructor() {
        this.x = 0;
        this.y = 0;
        this.health = "healthy";
        this.hasTools = false;
        this.hasTreasure = false;
      }
    }

    class GameMap {
      constructor() {
        this.size = 10;
        this.grid = Array.from({ length: this.size }, () =>
          Array.from({ length: this.size }, () => new Cell())
        );
        this.objects = {};
        this.unknownCycle = ["unknown1", "unknown2", "unknown3"];
        this.placeOuterWalls();
        this.placeInternalWalls();
        this.placeObjects();
      }

      placeOuterWalls() {
        for (let i = 0; i < this.size; i++) {
          this.grid[0][i].walls.up = true;
          this.grid[this.size - 1][i].walls.down = true;
          this.grid[i][0].walls.left = true;
          this.grid[i][this.size - 1].walls.right = true;
        }
      }

      placeInternalWalls() {
        let wallCount = 0;
        while (wallCount < 20) {
          const x = Math.floor(Math.random() * 8) + 1;
          const y = Math.floor(Math.random() * 8) + 1;
          const dirs = ["up", "down", "left", "right"];
          const dir = dirs[Math.floor(Math.random() * dirs.length)];
          const dxdy = { up: [-1, 0], down: [1, 0], left: [0, -1], right: [0, 1] };
          const [dx, dy] = dxdy[dir];
          const nx = x + dx, ny = y + dy;
          if (nx >= 0 && ny >= 0 && nx < this.size && ny < this.size) {
            this.grid[x][y].walls[dir] = true;
            const opposite = { up: "down", down: "up", left: "right", right: "left" };
            this.grid[nx][ny].walls[opposite[dir]] = true;
            wallCount++;
          }
        }
      }

      placeObjects() {
        const names = ["treasure", "fake_treasure", "tools", "med", "lion", "tiger", "unknown1", "unknown2", "unknown3", "exit"];
        const placed = new Set();
        for (const name of names) {
          while (true) {
            const x = Math.floor(Math.random() * 8) + 1;
            const y = Math.floor(Math.random() * 8) + 1;
            const key = `${x},${y}`;
            const tooClose = [...placed].some(pos => {
              const [px, py] = pos.split(',').map(Number);
              return Math.abs(px - x) + Math.abs(py - y) <= 2;
            });
            if (!placed.has(key) && !tooClose) {
              this.grid[x][y].object = name;
              this.objects[name] = [x, y];
              placed.add(key);
              break;
            }
          }
        }
      }

      getCell(x, y) {
        return this.grid[x][y];
      }
    }

    class Game {
      constructor() {
        this.map = new GameMap();
        this.player = new Player();
        [this.player.x, this.player.y] = [Math.floor(Math.random() * 8) + 1, Math.floor(Math.random() * 8) + 1];
        this.gameOver = false;
      }

      move(direction) {
        if (this.gameOver) return "–ò–≥—Ä–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞. –ù–∞–∂–º–∏—Ç–µ '–∑–∞–Ω–æ–≤–æ'.";

        const [dx, dy] = directions[direction];
        const cell = this.map.getCell(this.player.x, this.player.y);
        const wallKey = { "-1,0": "up", "1,0": "down", "0,-1": "left", "0,1": "right" }[[dx,dy].toString()];
        if (cell.walls[wallKey]) return "–°—Ç–µ–Ω–∫–∞";

        const nx = this.player.x + dx;
        const ny = this.player.y + dy;
        if (nx < 0 || ny < 0 || nx >= this.map.size || ny >= this.map.size) return "–°—Ç–µ–Ω–∫–∞ (–≥—Ä–∞–Ω–∏—Ü–∞)";
        this.player.x = nx;
        this.player.y = ny;
        return this.interact();
      }

      interact() {
        const cell = this.map.getCell(this.player.x, this.player.y);
        const obj = cell.object;

        if (this.player.health === "injured" && ["tools", "treasure", "fake_treasure", "exit"].includes(obj))
          return "–ù–∏—á–µ–≥–æ –∏–Ω—Ç–µ—Ä–µ—Å–Ω–æ–≥–æ";

        if (obj === "lion" || obj === "tiger") {
          this.player.health = "injured";
          this.player.hasTools = false;
          this.player.hasTreasure = false;
          return `–í—ã –≤—Å—Ç—Ä–µ—Ç–∏–ª–∏ ${obj === "lion" ? "–ª—å–≤–∞" : "—Ç–∏–≥—Ä–∞"}`;
        }

        if (obj === "med") {
          const prev = this.player.health;
          this.player.health = "healthy";
          return prev === "injured" ? "–í—ã –Ω–∞—à–ª–∏ –º–µ–¥–ø—É–Ω–∫—Ç" : "–í—ã –Ω–∞—à–ª–∏ –º–µ–¥–ø—É–Ω–∫—Ç (–≤—ã –∏ —Ç–∞–∫ –∑–¥–æ—Ä–æ–≤—ã)";
        }

        if (obj === "tools") {
          if (this.player.hasTools) return "–í—ã –Ω–∞—à–ª–∏ —Å–∫–ª–∞–¥ (–∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã —É–∂–µ –µ—Å—Ç—å)";
          this.player.hasTools = true;
          return "–í—ã –Ω–∞—à–ª–∏ —Å–∫–ª–∞–¥ (–ø–æ–ª—É—á–µ–Ω—ã –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã)";
        }

        if (obj === "treasure") {
          if (this.player.hasTools) {
            this.player.hasTools = false;
            this.player.hasTreasure = true;
            return "–í—ã –≤—ã–∫–æ–ø–∞–ª–∏ –∫–ª–∞–¥";
          }
          return "–í—ã –Ω–∞—à–ª–∏ –∫–ª–∞–¥ (–Ω—É–∂–Ω—ã –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã)";
        }

        if (obj === "fake_treasure") {
          if (this.player.hasTools) {
            this.player.hasTools = false;
            return "–í—ã –≤—ã–∫–æ–ø–∞–ª–∏ –ª–æ–∂–Ω—ã–π –∫–ª–∞–¥ (–∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã –ø–æ—Ç—Ä–∞—á–µ–Ω—ã)";
          }
          return "–í—ã –Ω–∞—à–ª–∏ –∫–ª–∞–¥ (–Ω—É–∂–Ω—ã –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã)";
        }

        if (obj === "exit") {
          if (this.player.hasTreasure) {
            this.gameOver = true;
            return "–í—ã –≤—ã–±—Ä–∞–ª–∏—Å—å —Å –∫–ª–∞–¥–æ–º ‚Äî –ø–æ–±–µ–¥–∞! –ù–∞–∂–º–∏—Ç–µ '–∑–∞–Ω–æ–≤–æ', —á—Ç–æ–±—ã —Å—ã–≥—Ä–∞—Ç—å —Å–Ω–æ–≤–∞.";
          }
          return "–í—ã –Ω–∞—à–ª–∏ –≤—ã—Ö–æ–¥";
        }

        if (this.map.unknownCycle.includes(obj)) {
          const idx = this.map.unknownCycle.indexOf(obj);
          const next = this.map.unknownCycle[(idx + 1) % 3];
          [this.player.x, this.player.y] = this.map.objects[next];
          return `–í—ã –ø–æ–ø–∞–ª–∏ –≤ ${obj}, –≤–∞—Å —Ç–µ–ª–µ–ø–æ—Ä—Ç–∏—Ä—É–µ—Ç –≤ ${next}`;
        }

        return "–ù–∏—á–µ–≥–æ –∏–Ω—Ç–µ—Ä–µ—Å–Ω–æ–≥–æ";
      }
    }

    let game = new Game();

    function send(cmd) {
      logMessage(`> ${cmd}`);
      const result = game.move(cmd);
      logMessage(result);
    }

    function restart() {
      game = new Game();
      log.textContent = "";
      logMessage("–ù–æ–≤–∞—è –∏–≥—Ä–∞ –Ω–∞—á–∞–ª–∞—Å—å. –í–≤–µ–¥–∏—Ç–µ –∫–æ–º–∞–Ω–¥—É.");
    }

    restart();
  </script>
</body>
</html>
